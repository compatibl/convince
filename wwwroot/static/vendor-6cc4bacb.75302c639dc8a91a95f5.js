"use strict";(self.webpackChunkui_react=self.webpackChunkui_react||[]).push([[3013],{2484:(t,i,e)=>{e.d(i,{Hs:()=>g,a$:()=>o});class n{constructor(t,i,e,n){this.originalStart=t,this.originalLength=i,this.modifiedStart=e,this.modifiedLength=n}getOriginalEnd(){return this.originalStart+this.originalLength}getModifiedEnd(){return this.modifiedStart+this.modifiedLength}}var r=e(89954);class s{constructor(t){this.source=t}getElements(){const t=this.source,i=new Int32Array(t.length);for(let e=0,n=t.length;e<n;e++)i[e]=t.charCodeAt(e);return i}}function o(t,i,e){return new g(new s(t),new s(i)).ComputeDiff(e).changes}class a{static Assert(t,i){if(!t)throw new Error(i)}}class l{static Copy(t,i,e,n,r){for(let s=0;s<r;s++)e[n+s]=t[i+s]}static Copy2(t,i,e,n,r){for(let s=0;s<r;s++)e[n+s]=t[i+s]}}class h{constructor(){this.m_changes=[],this.m_originalStart=1073741824,this.m_modifiedStart=1073741824,this.m_originalCount=0,this.m_modifiedCount=0}MarkNextChange(){(this.m_originalCount>0||this.m_modifiedCount>0)&&this.m_changes.push(new n(this.m_originalStart,this.m_originalCount,this.m_modifiedStart,this.m_modifiedCount)),this.m_originalCount=0,this.m_modifiedCount=0,this.m_originalStart=1073741824,this.m_modifiedStart=1073741824}AddOriginalElement(t,i){this.m_originalStart=Math.min(this.m_originalStart,t),this.m_modifiedStart=Math.min(this.m_modifiedStart,i),this.m_originalCount++}AddModifiedElement(t,i){this.m_originalStart=Math.min(this.m_originalStart,t),this.m_modifiedStart=Math.min(this.m_modifiedStart,i),this.m_modifiedCount++}getChanges(){return(this.m_originalCount>0||this.m_modifiedCount>0)&&this.MarkNextChange(),this.m_changes}getReverseChanges(){return(this.m_originalCount>0||this.m_modifiedCount>0)&&this.MarkNextChange(),this.m_changes.reverse(),this.m_changes}}class g{constructor(t,i,e=null){this.ContinueProcessingPredicate=e,this._originalSequence=t,this._modifiedSequence=i;const[n,r,s]=g._getElements(t),[o,a,l]=g._getElements(i);this._hasStrings=s&&l,this._originalStringElements=n,this._originalElementsOrHash=r,this._modifiedStringElements=o,this._modifiedElementsOrHash=a,this.m_forwardHistory=[],this.m_reverseHistory=[]}static _isStringArray(t){return t.length>0&&"string"==typeof t[0]}static _getElements(t){const i=t.getElements();if(g._isStringArray(i)){const t=new Int32Array(i.length);for(let e=0,n=i.length;e<n;e++)t[e]=(0,r.Cv)(i[e],0);return[i,t,!0]}return i instanceof Int32Array?[[],i,!1]:[[],new Int32Array(i),!1]}ElementsAreEqual(t,i){return this._originalElementsOrHash[t]===this._modifiedElementsOrHash[i]&&(!this._hasStrings||this._originalStringElements[t]===this._modifiedStringElements[i])}ElementsAreStrictEqual(t,i){if(!this.ElementsAreEqual(t,i))return!1;return g._getStrictElement(this._originalSequence,t)===g._getStrictElement(this._modifiedSequence,i)}static _getStrictElement(t,i){return"function"==typeof t.getStrictElement?t.getStrictElement(i):null}OriginalElementsAreEqual(t,i){return this._originalElementsOrHash[t]===this._originalElementsOrHash[i]&&(!this._hasStrings||this._originalStringElements[t]===this._originalStringElements[i])}ModifiedElementsAreEqual(t,i){return this._modifiedElementsOrHash[t]===this._modifiedElementsOrHash[i]&&(!this._hasStrings||this._modifiedStringElements[t]===this._modifiedStringElements[i])}ComputeDiff(t){return this._ComputeDiff(0,this._originalElementsOrHash.length-1,0,this._modifiedElementsOrHash.length-1,t)}_ComputeDiff(t,i,e,n,r){const s=[!1];let o=this.ComputeDiffRecursive(t,i,e,n,s);return r&&(o=this.PrettifyChanges(o)),{quitEarly:s[0],changes:o}}ComputeDiffRecursive(t,i,e,r,s){for(s[0]=!1;t<=i&&e<=r&&this.ElementsAreEqual(t,e);)t++,e++;for(;i>=t&&r>=e&&this.ElementsAreEqual(i,r);)i--,r--;if(t>i||e>r){let s;return e<=r?(a.Assert(t===i+1,"originalStart should only be one more than originalEnd"),s=[new n(t,0,e,r-e+1)]):t<=i?(a.Assert(e===r+1,"modifiedStart should only be one more than modifiedEnd"),s=[new n(t,i-t+1,e,0)]):(a.Assert(t===i+1,"originalStart should only be one more than originalEnd"),a.Assert(e===r+1,"modifiedStart should only be one more than modifiedEnd"),s=[]),s}const o=[0],l=[0],h=this.ComputeRecursionPoint(t,i,e,r,o,l,s),g=o[0],d=l[0];if(null!==h)return h;if(!s[0]){const o=this.ComputeDiffRecursive(t,g,e,d,s);let a=[];return a=s[0]?[new n(g+1,i-(g+1)+1,d+1,r-(d+1)+1)]:this.ComputeDiffRecursive(g+1,i,d+1,r,s),this.ConcatenateChanges(o,a)}return[new n(t,i-t+1,e,r-e+1)]}WALKTRACE(t,i,e,r,s,o,a,l,g,d,m,f,u,c,S,_,E,C){let y=null,A=null,L=new h,p=i,w=e,O=u[0]-_[0]-r,M=-1073741824,q=this.m_forwardHistory.length-1;do{const i=O+t;i===p||i<w&&g[i-1]<g[i+1]?(c=(m=g[i+1])-O-r,m<M&&L.MarkNextChange(),M=m,L.AddModifiedElement(m+1,c),O=i+1-t):(c=(m=g[i-1]+1)-O-r,m<M&&L.MarkNextChange(),M=m-1,L.AddOriginalElement(m,c+1),O=i-1-t),q>=0&&(t=(g=this.m_forwardHistory[q])[0],p=1,w=g.length-1)}while(--q>=-1);if(y=L.getReverseChanges(),C[0]){let t=u[0]+1,i=_[0]+1;if(null!==y&&y.length>0){const e=y[y.length-1];t=Math.max(t,e.getOriginalEnd()),i=Math.max(i,e.getModifiedEnd())}A=[new n(t,f-t+1,i,S-i+1)]}else{L=new h,p=o,w=a,O=u[0]-_[0]-l,M=1073741824,q=E?this.m_reverseHistory.length-1:this.m_reverseHistory.length-2;do{const t=O+s;t===p||t<w&&d[t-1]>=d[t+1]?(c=(m=d[t+1]-1)-O-l,m>M&&L.MarkNextChange(),M=m+1,L.AddOriginalElement(m+1,c+1),O=t+1-s):(c=(m=d[t-1])-O-l,m>M&&L.MarkNextChange(),M=m,L.AddModifiedElement(m+1,c+1),O=t-1-s),q>=0&&(s=(d=this.m_reverseHistory[q])[0],p=1,w=d.length-1)}while(--q>=-1);A=L.getChanges()}return this.ConcatenateChanges(y,A)}ComputeRecursionPoint(t,i,e,r,s,o,a){let h=0,g=0,d=0,m=0,f=0,u=0;t--,e--,s[0]=0,o[0]=0,this.m_forwardHistory=[],this.m_reverseHistory=[];const c=i-t+(r-e),S=c+1,_=new Int32Array(S),E=new Int32Array(S),C=r-e,y=i-t,A=t-e,L=i-r,p=(y-C)%2==0;_[C]=t,E[y]=i,a[0]=!1;for(let w=1;w<=c/2+1;w++){let c=0,O=0;d=this.ClipDiagonalBound(C-w,w,C,S),m=this.ClipDiagonalBound(C+w,w,C,S);for(let t=d;t<=m;t+=2){h=t===d||t<m&&_[t-1]<_[t+1]?_[t+1]:_[t-1]+1,g=h-(t-C)-A;const e=h;for(;h<i&&g<r&&this.ElementsAreEqual(h+1,g+1);)h++,g++;if(_[t]=h,h+g>c+O&&(c=h,O=g),!p&&Math.abs(t-y)<=w-1&&h>=E[t])return s[0]=h,o[0]=g,e<=E[t]&&w<=1448?this.WALKTRACE(C,d,m,A,y,f,u,L,_,E,h,i,s,g,r,o,p,a):null}const M=(c-t+(O-e)-w)/2;if(null!==this.ContinueProcessingPredicate&&!this.ContinueProcessingPredicate(c,M))return a[0]=!0,s[0]=c,o[0]=O,M>0&&w<=1448?this.WALKTRACE(C,d,m,A,y,f,u,L,_,E,h,i,s,g,r,o,p,a):(t++,e++,[new n(t,i-t+1,e,r-e+1)]);f=this.ClipDiagonalBound(y-w,w,y,S),u=this.ClipDiagonalBound(y+w,w,y,S);for(let n=f;n<=u;n+=2){h=n===f||n<u&&E[n-1]>=E[n+1]?E[n+1]-1:E[n-1],g=h-(n-y)-L;const l=h;for(;h>t&&g>e&&this.ElementsAreEqual(h,g);)h--,g--;if(E[n]=h,p&&Math.abs(n-C)<=w&&h<=_[n])return s[0]=h,o[0]=g,l>=_[n]&&w<=1448?this.WALKTRACE(C,d,m,A,y,f,u,L,_,E,h,i,s,g,r,o,p,a):null}if(w<=1447){let t=new Int32Array(m-d+2);t[0]=C-d+1,l.Copy2(_,d,t,1,m-d+1),this.m_forwardHistory.push(t),t=new Int32Array(u-f+2),t[0]=y-f+1,l.Copy2(E,f,t,1,u-f+1),this.m_reverseHistory.push(t)}}return this.WALKTRACE(C,d,m,A,y,f,u,L,_,E,h,i,s,g,r,o,p,a)}PrettifyChanges(t){for(let i=0;i<t.length;i++){const e=t[i],n=i<t.length-1?t[i+1].originalStart:this._originalElementsOrHash.length,r=i<t.length-1?t[i+1].modifiedStart:this._modifiedElementsOrHash.length,s=e.originalLength>0,o=e.modifiedLength>0;for(;e.originalStart+e.originalLength<n&&e.modifiedStart+e.modifiedLength<r&&(!s||this.OriginalElementsAreEqual(e.originalStart,e.originalStart+e.originalLength))&&(!o||this.ModifiedElementsAreEqual(e.modifiedStart,e.modifiedStart+e.modifiedLength));){const t=this.ElementsAreStrictEqual(e.originalStart,e.modifiedStart);if(this.ElementsAreStrictEqual(e.originalStart+e.originalLength,e.modifiedStart+e.modifiedLength)&&!t)break;e.originalStart++,e.modifiedStart++}const a=[null];i<t.length-1&&this.ChangesOverlap(t[i],t[i+1],a)&&(t[i]=a[0],t.splice(i+1,1),i--)}for(let i=t.length-1;i>=0;i--){const e=t[i];let n=0,r=0;if(i>0){const e=t[i-1];n=e.originalStart+e.originalLength,r=e.modifiedStart+e.modifiedLength}const s=e.originalLength>0,o=e.modifiedLength>0;let a=0,l=this._boundaryScore(e.originalStart,e.originalLength,e.modifiedStart,e.modifiedLength);for(let t=1;;t++){const i=e.originalStart-t,h=e.modifiedStart-t;if(i<n||h<r)break;if(s&&!this.OriginalElementsAreEqual(i,i+e.originalLength))break;if(o&&!this.ModifiedElementsAreEqual(h,h+e.modifiedLength))break;const g=(i===n&&h===r?5:0)+this._boundaryScore(i,e.originalLength,h,e.modifiedLength);g>l&&(l=g,a=t)}e.originalStart-=a,e.modifiedStart-=a;const h=[null];i>0&&this.ChangesOverlap(t[i-1],t[i],h)&&(t[i-1]=h[0],t.splice(i,1),i++)}if(this._hasStrings)for(let i=1,e=t.length;i<e;i++){const e=t[i-1],n=t[i],r=n.originalStart-e.originalStart-e.originalLength,s=e.originalStart,o=n.originalStart+n.originalLength,a=o-s,l=e.modifiedStart,h=n.modifiedStart+n.modifiedLength,g=h-l;if(r<5&&a<20&&g<20){const t=this._findBetterContiguousSequence(s,a,l,g,r);if(t){const[i,s]=t;i===e.originalStart+e.originalLength&&s===e.modifiedStart+e.modifiedLength||(e.originalLength=i-e.originalStart,e.modifiedLength=s-e.modifiedStart,n.originalStart=i+r,n.modifiedStart=s+r,n.originalLength=o-n.originalStart,n.modifiedLength=h-n.modifiedStart)}}}return t}_findBetterContiguousSequence(t,i,e,n,r){if(i<r||n<r)return null;const s=t+i-r+1,o=e+n-r+1;let a=0,l=0,h=0;for(let i=t;i<s;i++)for(let t=e;t<o;t++){const e=this._contiguousSequenceScore(i,t,r);e>0&&e>a&&(a=e,l=i,h=t)}return a>0?[l,h]:null}_contiguousSequenceScore(t,i,e){let n=0;for(let r=0;r<e;r++){if(!this.ElementsAreEqual(t+r,i+r))return 0;n+=this._originalStringElements[t+r].length}return n}_OriginalIsBoundary(t){return t<=0||t>=this._originalElementsOrHash.length-1||this._hasStrings&&/^\s*$/.test(this._originalStringElements[t])}_OriginalRegionIsBoundary(t,i){if(this._OriginalIsBoundary(t)||this._OriginalIsBoundary(t-1))return!0;if(i>0){const e=t+i;if(this._OriginalIsBoundary(e-1)||this._OriginalIsBoundary(e))return!0}return!1}_ModifiedIsBoundary(t){return t<=0||t>=this._modifiedElementsOrHash.length-1||this._hasStrings&&/^\s*$/.test(this._modifiedStringElements[t])}_ModifiedRegionIsBoundary(t,i){if(this._ModifiedIsBoundary(t)||this._ModifiedIsBoundary(t-1))return!0;if(i>0){const e=t+i;if(this._ModifiedIsBoundary(e-1)||this._ModifiedIsBoundary(e))return!0}return!1}_boundaryScore(t,i,e,n){return(this._OriginalRegionIsBoundary(t,i)?1:0)+(this._ModifiedRegionIsBoundary(e,n)?1:0)}ConcatenateChanges(t,i){const e=[];if(0===t.length||0===i.length)return i.length>0?i:t;if(this.ChangesOverlap(t[t.length-1],i[0],e)){const n=new Array(t.length+i.length-1);return l.Copy(t,0,n,0,t.length-1),n[t.length-1]=e[0],l.Copy(i,1,n,t.length,i.length-1),n}{const e=new Array(t.length+i.length);return l.Copy(t,0,e,0,t.length),l.Copy(i,0,e,t.length,i.length),e}}ChangesOverlap(t,i,e){if(a.Assert(t.originalStart<=i.originalStart,"Left change is not less than or equal to right change"),a.Assert(t.modifiedStart<=i.modifiedStart,"Left change is not less than or equal to right change"),t.originalStart+t.originalLength>=i.originalStart||t.modifiedStart+t.modifiedLength>=i.modifiedStart){const r=t.originalStart;let s=t.originalLength;const o=t.modifiedStart;let a=t.modifiedLength;return t.originalStart+t.originalLength>=i.originalStart&&(s=i.originalStart+i.originalLength-t.originalStart),t.modifiedStart+t.modifiedLength>=i.modifiedStart&&(a=i.modifiedStart+i.modifiedLength-t.modifiedStart),e[0]=new n(r,s,o,a),!0}return e[0]=null,!1}ClipDiagonalBound(t,i,e,n){if(t>=0&&t<n)return t;const r=i%2==0;if(t<0){return r===(e%2==0)?0:1}return r===((n-e-1)%2==0)?n-1:n-2}}}}]);